<html style="text-align:center">
  <canvas id="canvasElement" width=800 height=600 style="display:inline-block;border-style:solid;border-width:2px" onclick="toggleAffine()"/>

  <img id="textureImage" src="checkeredmap.jpg" alt="The Scream" width="1024" height="1024" style="display:none">

  <script type="text/javascript" src="Core.js"></script>
  <script type="text/javascript" src="ObjLoader.js"></script>
  <script type="text/javascript" src="Cube.obj.js"></script>
  <script type="text/javascript" src="brick.image.js"></script>
  <script type="text/javascript" src="teapot.js"></script>
  <script type="text/javascript">

    const canvasHeight = 600;
    const canvasWidth = 800;

    const vertexBuffer = [];

    function toggleAffine() {
      affineToggle = !affineToggle;
    }

    function getCanvasContext() {
      const canvasElement = document.getElementById('canvasElement');
      const context = canvasElement.getContext('2d');
      return context;
    }

    let textureMap = brickData;
    // document.getElementById('textureImage').onload = () => {
    //   // let textureImage = document.getElementById('textureImage');
    //   // let textureCanvas = document.createElement('canvas');
    //   // textureCanvas.width = 1024;
    //   // textureCanvas.height = 1024;
    //   // let textureContext = textureCanvas.getContext('2d');
//
    //   // // Create hidden canvas for our textureMap
    //   // textureContext.drawImage(textureImage, 0, 0);
    //   // textureMap = textureContext.getImageData(0,0,1024,1024);
    //   // debugger;
    // }

    let vertexNormals = [];
    function init() {
      context = getCanvasContext();
      context.translate(canvasWidth / 2, canvasHeight / 2);

      // Load model into vertexBuffer.
      const sphereGeo = loadObj(cubeData);
      teapotVerts = sphereGeo.vertices;
      vertexNormals = sphereGeo.normals;
      teapotFaces = sphereGeo.triangles;
      teapotUvs = sphereGeo.uvs;

      // Calculate vertex normals.
      // for (let index = 0; index < teapotVerts.length; index++) {
      //   for (const triangle of teapotFaces) {
      //     if (triangle.v1 - 1 === index || triangle.v2 - 1 === index || triangle.v3 - 1 === index) {
      //       // This face is using our vertex so let's calculate normal.
      //       const v1 = teapotVerts[triangle.v1 - 1];
      //       const v2 = teapotVerts[triangle.v2 - 1];
      //       const v3 = teapotVerts[triangle.v3 - 1];
      //       const faceNormal = v2.subtract(v1).crossProduct(v3.subtract(v1)).normalized();
      //       vertexNormals[index] = vertexNormals[index] || [];
      //       vertexNormals[index].push(faceNormal);
      //     }
      //   }
      // }

      // for (let index = 0; index < vertexNormals.length; index++) {
      //   const normalsList = vertexNormals[index];
      //   let output = new Vector4(0,0,0);
      //   for (const normal of normalsList) {
      //     output.x += normal.x;
      //     output.y += normal.y;
      //     output.z += normal.z;
      //   }
      //   output = output.normalized();
      //   vertexNormals[index] = output;
      // }
    }

    let rotation = 0 * (Math.PI / 180);
    function render() {
      deltaTime = (Date.now() - previousTime) / 1000;
      previousTime = Date.now();
      rotation += 0.1 * deltaTime;
      //rotation = 180 * (Math.PI / 180);
      lightLocation.x = Math.cos(Date.now() / 500) * 400;
      //lightLocation.z = Math.sin(Date.now() / 500) * 400 + 40;
      // lightLocation.x = -300;

      context = getCanvasContext();
      context.clearRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);

      // let verticies = [
      //   new Vector4(10, -10, -10, 1),
      //   new Vector4(-10, -10, -10, 1),
      //   new Vector4(-10, 10, -10, 1),
      //   new Vector4(10, 10, -10, 1),
      //   new Vector4(10, -10, -10, 1),
      //
      //   new Vector4(10, -10, 10, 1),
      //   new Vector4(-10, -10, 10, 1),
      //   new Vector4(-10, 10, 10, 1),
      //   new Vector4(10, 10, 10, 1),
      //   new Vector4(10, -10, 10, 1),
      //
      //   new Vector4(10, -10, -10, 1),
      //   new Vector4(10, 10, -10, 1),
      //   new Vector4(10, 10, 10, 1),
      //
      //   new Vector4(-10, 10, 10, 1),
      //   new Vector4(-10, 10, -10, 1),
      //   new Vector4(-10, -10, -10, 1),
      //   new Vector4(-10, -10, 10, 1),
      // ];

      const canvas = new Canvas(context);

      // Sort faces by distance before drawing.
      /*
      teapotFaces.sort((a,b) => {
        const cameraPosition = new Vector4();

        aCentroid = transformedVerts[a.v1 - 1].add(transformedVerts[a.v2 - 1]).add(transformedVerts[a.v3 - 1]).scale(1 / 3);
        bCentroid = transformedVerts[b.v1 - 1].add(transformedVerts[b.v2 - 1]).add(transformedVerts[b.v3 - 1]).scale(1 / 3);

        const aDistance = cameraPosition.distance(aCentroid);
        const bDistance = cameraPosition.distance(bCentroid);
        if (aDistance < bDistance) {
          return 1;
        }

        if (aDistance > bDistance) {
          return -1;
        }

        return 0;
      });*/

      for (const triangle of teapotFaces) {
        let w1 = teapotVerts[triangle.vertices.v1];
        let w2 = teapotVerts[triangle.vertices.v2];
        let w3 = teapotVerts[triangle.vertices.v3];
        let u1 = transformVertex(w1)
        let u2 = transformVertex(w2)
        let u3 = transformVertex(w3)
        let v1 = projectVertex(u1);
        let v2 = projectVertex(u2);
        let v3 = projectVertex(u3);

        let uv1 = teapotUvs[triangle.uvs.v1];
        let uv2 = teapotUvs[triangle.uvs.v2];
        let uv3 = teapotUvs[triangle.uvs.v3];

        let generatedNormal = u2.subtract(u1).crossProduct(u3.subtract(u1)).normalized();

        // Backface culling.
        if (u1.scale(-1).dotProduct(generatedNormal) >= 0) { // If this face is pointed to our camera, draw it.
          const rotateNormal  = (normal) => {
            const rotationMatrix = new Matrix4();
            rotationMatrix.m00 = Math.cos(rotation);
            rotationMatrix.m11 = 1;
            rotationMatrix.m22 = Math.cos(rotation);
            rotationMatrix.m20 = -Math.sin(rotation);
            rotationMatrix.m02 = Math.sin(rotation);
            return rotationMatrix.multiply(normal);
          };
          let n1 = rotateNormal(vertexNormals[triangle.normals.v1]);
          let n2 = rotateNormal(vertexNormals[triangle.normals.v2]);
          let n3 = rotateNormal(vertexNormals[triangle.normals.v3]);

          let faceColor = u2.subtract(u1).crossProduct(u3.subtract(u1)).normalized();
          const red = Math.floor((faceColor.x + 1) / 2 * 255);
          const green = Math.floor((faceColor.y + 1) / 2 * 255);
          const blue = Math.floor((faceColor.z + 1) / 2 * 255);
          const finalColor = new Vector4(red, green, blue, 255);
          canvas.calculateFragment({v1:uv1, v2:uv2, v3:uv3}, {w1: u1, w2: u2, w3: u3}, {v1, v2, v3}, {n1, n2, n3}, finalColor);
        }
      }

      canvas.submitImageData();

      context.fillStyle = '#444444';
      context.fillText(`Frame Time: ${deltaTime}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 20);
      context.fillText(`Triangles: ${teapotFaces.length}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 40);
      context.fillText(`Vertices: ${teapotVerts.length}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 60);
      context.fillText(`Light: (${lightLocation.x},${lightLocation.y},${lightLocation.z})`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 80);
    }

    function transformVertex(vertex) {
      let translationMatrix = new Matrix4();
      translationMatrix.m00 = 1;
      translationMatrix.m11 = 1;
      translationMatrix.m22 = 1;
      translationMatrix.m33 = 1;
      translationMatrix.m32 = 40;
      translationMatrix.m30 = 40;

      let scaleMatrix = new Matrix4();
      scaleMatrix.m00 = 15;
      scaleMatrix.m11 = 15;
      scaleMatrix.m22 = 15;
      scaleMatrix.m33 = 1;
      let scaled = scaleMatrix.multiply(vertex);

      // Rotate around Y-axis
      const rotated = new Vector4();
      const angleCos = Math.cos(rotation);
      const angleSin = Math.sin(rotation);
      rotated.x = scaled.x * angleCos + scaled.z * angleSin;
      rotated.z = -scaled.x * angleSin + scaled.z * angleCos;

      rotated.y = scaled.y;
      rotated.w = scaled.w;

      // Translate forward.
      const translated = rotated;
      translated.z += 40;
      translated.y -= 10;

      return translated;
    }

    const perspectiveMatrix = makePerspective(0.1 * (Math.PI / 180), canvasWidth / canvasHeight, nearPlane, farPlane);
    function projectVertex(vertex) {

      // Multiply by our projection matrix to get screen coordinates.
      let projected = perspectiveMatrix.multiply(vertex);
      return projected;
    }
    // let projectionTest01 = projectVertex(new Vector4(0,0,0)).z;
    // let projectionTest0 = projectVertex(new Vector4(0,0,nearPlane)).z;
    // let projectionTest1 = projectVertex(new Vector4(0,0,1.5)).z;
    // let projectionTest342 = projectVertex(new Vector4(0,0,1.98)).z;
    // let projectionTest2 = projectVertex(new Vector4(0,0,farPlane * 0.1)).z;
    // let projectionTest3 = projectVertex(new Vector4(0,0,farPlane * 0.25)).z;
    // let projectionTest4 = projectVertex(new Vector4(0,0,farPlane * 0.5)).z;
    // let projectionTest5 = projectVertex(new Vector4(0,0,farPlane * 0.75)).z;
    // let projectionTest6 = projectVertex(new Vector4(0,0,farPlane * 0.99)).z;
    // let projectionTest7 = projectVertex(new Vector4(0,0,farPlane * 1)).z;
    // let projectionTest8 = projectVertex(new Vector4(0,0,farPlane * 1.25)).z;
    // debugger;

    function gameLoop() {
      window.requestAnimationFrame(gameLoop);
      render();
    }

    const frameLimit = 30;
    let deltaTime = 1000 / frameLimit;
    let previousTime = Date.now();

    init();
    gameLoop();
  </script>
</html>
