<html style="text-align:center">
  <canvas id="canvasElement" width=800 height=600 style="display:inline-block;border-style:solid;border-width:2px"/>

  <script type="text/javascript" src="Core.js"></script>
  <script type="text/javascript" src="teapot.js"></script>
  <script type="text/javascript">
    const canvasHeight = 600;
    const canvasWidth = 800;

    const vertexBuffer = [];

    function getCanvasContext() {
      const canvasElement = document.getElementById('canvasElement');
      const context = canvasElement.getContext('2d');
      return context;
    }

    let vertexNormals = [];
    function init() {
      context = getCanvasContext();
      context.translate(canvasWidth / 2, canvasHeight / 2);

      // Load model into vertexBuffer.

      // Calculate vertex normals.
      for (let index = 0; index < teapotVerts.length; index++) {
        for (const triangle of teapotFaces) {
          if (triangle.v1 - 1 === index || triangle.v2 - 1 === index || triangle.v3 - 1 === index) {
            // This face is using our vertex so let's calculate normal.
            const v1 = teapotVerts[triangle.v1 - 1];
            const v2 = teapotVerts[triangle.v2 - 1];
            const v3 = teapotVerts[triangle.v3 - 1];
            const faceNormal = v2.subtract(v1).crossProduct(v3.subtract(v1)).normalized();
            vertexNormals[index] = vertexNormals[index] || [];
            vertexNormals[index].push(faceNormal);
          }
        }
      }

      for (let index = 0; index < vertexNormals.length; index++) {
        const normalsList = vertexNormals[index];
        let output = new Vector4(0,0,0);
        for (const normal of normalsList) {
          output.x += normal.x;
          output.y += normal.y;
          output.z += normal.z;
        }
        output = output.normalized();
        vertexNormals[index] = output;
      }
    }

    let rotation = 0 * (Math.PI / 180);
    function render() {
      deltaTime = (Date.now() - previousTime) / 1000;
      previousTime = Date.now();
      rotation += 0.5 * deltaTime;
      lightLocation.x = Math.cos(Date.now() / 1000) * 400;

      context = getCanvasContext();
      context.clearRect(-canvasWidth / 2, -canvasHeight / 2, canvasWidth, canvasHeight);

      // let verticies = [
      //   new Vector4(10, -10, -10, 1),
      //   new Vector4(-10, -10, -10, 1),
      //   new Vector4(-10, 10, -10, 1),
      //   new Vector4(10, 10, -10, 1),
      //   new Vector4(10, -10, -10, 1),
      //
      //   new Vector4(10, -10, 10, 1),
      //   new Vector4(-10, -10, 10, 1),
      //   new Vector4(-10, 10, 10, 1),
      //   new Vector4(10, 10, 10, 1),
      //   new Vector4(10, -10, 10, 1),
      //
      //   new Vector4(10, -10, -10, 1),
      //   new Vector4(10, 10, -10, 1),
      //   new Vector4(10, 10, 10, 1),
      //
      //   new Vector4(-10, 10, 10, 1),
      //   new Vector4(-10, 10, -10, 1),
      //   new Vector4(-10, -10, -10, 1),
      //   new Vector4(-10, -10, 10, 1),
      // ];

      const canvas = new Canvas(context);

      // Sort faces by distance before drawing.
      /*
      teapotFaces.sort((a,b) => {
        const cameraPosition = new Vector4();

        aCentroid = transformedVerts[a.v1 - 1].add(transformedVerts[a.v2 - 1]).add(transformedVerts[a.v3 - 1]).scale(1 / 3);
        bCentroid = transformedVerts[b.v1 - 1].add(transformedVerts[b.v2 - 1]).add(transformedVerts[b.v3 - 1]).scale(1 / 3);

        const aDistance = cameraPosition.distance(aCentroid);
        const bDistance = cameraPosition.distance(bCentroid);
        if (aDistance < bDistance) {
          return 1;
        }

        if (aDistance > bDistance) {
          return -1;
        }

        return 0;
      });*/

      for (const face of teapotFaces) {
        let w1 = teapotVerts[face.v1 - 1];
        let w2 = teapotVerts[face.v2 - 1];
        let w3 = teapotVerts[face.v3 - 1];
        let u1 = transformVertex(w1) // transformedVerts[face.v1 - 1];
        let u2 = transformVertex(w2) // transformedVerts[face.v2 - 1];
        let u3 = transformVertex(w3) // transformedVerts[face.v3 - 1];
        let v1 = projectVertex(u1);
        let v2 = projectVertex(u2);
        let v3 = projectVertex(u3);


        // let temp = {v1, v2, v3};
        // let utemp = {u1, u2, u3};
        // debugger;

        let generatedNormal = u2.subtract(u1).crossProduct(u3.subtract(u1)).normalized();

        // Backface culling.
        if (u1.scale(-1).dotProduct(generatedNormal) >= 0) { // If this face is pointed to our camera, draw it.
          const rotateNormal  = (normal) => {
            const rotationMatrix = new Matrix4();
            rotationMatrix.m00 = Math.cos(rotation);
            rotationMatrix.m11 = 1;
            rotationMatrix.m22 = Math.cos(rotation);
            rotationMatrix.m20 = -Math.sin(rotation);
            rotationMatrix.m02 = Math.sin(rotation);
            return rotationMatrix.multiply(normal);
          };
          let n1 = rotateNormal(vertexNormals[face.v1 - 1]);
          let n2 = rotateNormal(vertexNormals[face.v2 - 1]);
          let n3 = rotateNormal(vertexNormals[face.v3 - 1]);

          let faceColor = u2.subtract(u1).crossProduct(u3.subtract(u1)).normalized();
          const red = Math.floor((faceColor.x + 1) / 2 * 255);
          const green = Math.floor((faceColor.y + 1) / 2 * 255);
          const blue = Math.floor((faceColor.z + 1) / 2 * 255);
          const finalColor = new Vector4(red, green, blue, 255);
          canvas.calculateFragment({v1, v2, v3}, {n1, n2, n3}, finalColor);
        }
      }

      canvas.submitImageData();

      context.fillStyle = '#444444';
      context.fillText(`Frame Time: ${deltaTime}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 20);
      context.fillText(`Triangles: ${teapotFaces.length}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 40);
      context.fillText(`Verticies: ${teapotVerts.length}`, (canvasWidth / -2) + 15, (canvasHeight / -2) + 60);
    }

    function transformVertex(vertex) {
      let translationMatrix = new Matrix4();
      translationMatrix.m00 = 1;
      translationMatrix.m11 = 1;
      translationMatrix.m22 = 1;
      translationMatrix.m33 = 1;
      translationMatrix.m32 = 40;
      translationMatrix.m30 = 40;

      let scaleMatrix = new Matrix4();
      scaleMatrix.m00 = 8;
      scaleMatrix.m11 = 8;
      scaleMatrix.m22 = 8;
      scaleMatrix.m33 = 1;
      let scaled = scaleMatrix.multiply(vertex);

      // Rotate around Y-axis
      const rotated = new Vector4();
      const angleCos = Math.cos(rotation);
      const angleSin = Math.sin(rotation);
      rotated.x = scaled.x * angleCos + scaled.z * angleSin;
      rotated.z = -scaled.x * angleSin + scaled.z * angleCos;

      // rotated.x = vertex.x * angleCos + vertex.z * angleSin;
      // rotated.y = vertex.y;
      //rotated.z = -vertex.x * angleSin + vertex.z * angleCos;
      rotated.y = scaled.y;
      rotated.w = scaled.w;

      // Translate forward.
      const translated = rotated;
      translated.z += 40;
      translated.y -= 10;

      return translated;
    }

    const perspectiveMatrix = makePerspective(0.25 * (Math.PI / 180), canvasWidth / canvasHeight, nearPlane, farPlane);
    function projectVertex(vertex) {

      // Multiply by our projection matrix to get screen coordinates.
      let projected = perspectiveMatrix.multiply(vertex);
      return projected;
    }
    let projectionTest01 = projectVertex(new Vector4(0,0,0)).z;
    let projectionTest0 = projectVertex(new Vector4(0,0,nearPlane)).z;
    let projectionTest1 = projectVertex(new Vector4(0,0,1.5)).z;
    let projectionTest342 = projectVertex(new Vector4(0,0,1.98)).z;
    let projectionTest2 = projectVertex(new Vector4(0,0,farPlane * 0.1)).z;
    let projectionTest3 = projectVertex(new Vector4(0,0,farPlane * 0.25)).z;
    let projectionTest4 = projectVertex(new Vector4(0,0,farPlane * 0.5)).z;
    let projectionTest5 = projectVertex(new Vector4(0,0,farPlane * 0.75)).z;
    let projectionTest6 = projectVertex(new Vector4(0,0,farPlane * 0.99)).z;
    let projectionTest7 = projectVertex(new Vector4(0,0,farPlane * 1)).z;
    let projectionTest8 = projectVertex(new Vector4(0,0,farPlane * 1.25)).z;
    // debugger;

    function gameLoop() {
      window.requestAnimationFrame(gameLoop);
      render();
    }

    const frameLimit = 30;
    let deltaTime = 1000 / frameLimit;
    let previousTime = Date.now();

    init();
    gameLoop();
  </script>
</html>
